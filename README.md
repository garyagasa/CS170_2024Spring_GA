# CS170 Spring 2024 LeetCode Weekly Plan

Below is a curated list of LeetCode problems for each week of the CS170 Spring 2024 course at UC Berkeley. The problems are selected to align with the course’s lecture topics, ensuring they reinforce the concepts taught each week. Each week’s problems are designed to be solvable within approximately 3 hours, with a focus on moderate difficulty to suit students progressing through the course. For advanced topics like Fast Fourier Transform (FFT) or Linear Programming, where direct LeetCode problems may not exist, related algorithmic problems are chosen to approximate the concepts.
- [Course Website](https://tree.yuantsy.com/Course2/docs/CS170Spring2024/)

## Progress Tracking
+ [x] week 1
+ [x] week 2
+ [x] week 3
+ [ ] week 4
+ [ ] week 5
+ [ ] week 6
+ [ ] week 7
+ [ ] week 8
+ [ ] week 9
+ [ ] week 10
+ [ ] week 11
+ [ ] week 12
+ [ ] week 13
+ [ ] week 14
+ [ ] week 15

## Weekly Problem Recommendations

| **Week** | **Topics** | **Recommended Problems** |
|----------|------------|--------------------------|
| **1**    | Introduction, Big-O Notation, Arithmetic; Integer Multiplication, Recurrence Relations, Master Theorem | - [704. Binary Search](https://leetcode.cn/problems/binary-search/) (Easy): Practice binary search to understand logarithmic time complexity.<br> - [35. Search Insert Position](https://leetcode.cn/problems/search-insert-position/) (Easy): Apply binary search to find insertion points.<br> - [69. Sqrt(x)](https://leetcode.cn/problems/sqrtx/) (Easy): Use binary search for numerical computation. |
| **2**    | Matrix Multiplication, Median-Finding; Fast Fourier Transform (Part I) | - [74. Search a 2D Matrix](https://leetcode.cn/problems/search-a-2d-matrix/) (Medium): Search in a sorted matrix, related to matrix operations.<br> - [54. Spiral Matrix](https://leetcode.cn/problems/spiral-matrix/) (Medium): Traverse a matrix in spiral order.<br> - [215. Kth Largest Element in an Array](https://leetcode.cn/problems/kth-largest-element-in-an-array/) (Medium): Find the kth largest element, akin to median-finding. |
| **3**    | Fast Fourier Transform (Part II); Depth First Search, Topological Sort | - [207. Course Schedule](https://leetcode.cn/problems/course-schedule/) (Medium): Implement topological sort to detect cycles.<br> - [133. Clone Graph](https://leetcode.cn/problems/clone-graph/) (Medium): Use DFS to clone a graph.<br> - [46. Permutations](https://leetcode.cn/problems/permutations/) (Medium): Apply DFS for generating permutations. |
| **4**    | Strongly Connected Components; Paths in Graphs | - [743. Network Delay Time](https://leetcode.cn/problems/network-delay-time/) (Medium): Compute shortest paths using Dijkstra’s algorithm.<br> - [994. Rotting Oranges](https://leetcode.cn/problems/rotting-oranges/) (Medium): Use BFS on a grid to simulate spreading.<br> - [200. Number of Islands](https://leetcode.cn/problems/number-of-islands/) (Medium): Apply DFS/BFS to find connected components. |
| **5**    | Greedy Algorithms, Huffman Encoding; Minimum Spanning Trees | - [55. Jump Game](https://leetcode.cn/problems/jump-game/) (Medium): Solve using a greedy approach.<br> - [973. K Closest Points to Origin](https://leetcode.cn/problems/k-closest-points-to-origin/) (Medium): Use a heap, similar to Huffman encoding.<br> - [1584. Min Cost to Connect All Points](https://leetcode.cn/problems/min-cost-to-connect-all-points/) (Medium): Implement Kruskal’s algorithm for MST. |
| **6**    | Union Find, Horn Formulas; Dynamic Programming (Part I) | - [547. Number of Provinces](https://leetcode.cn/problems/number-of-provinces/) (Medium): Use Union Find to find connected components.<br> - [70. Climbing Stairs](https://leetcode.cn/problems/climbing-stairs/) (Easy): Introduce basic dynamic programming.<br> - [53. Maximum Subarray](https://leetcode.cn/problems/maximum-subarray/) (Easy): Apply DP to find the maximum subarray sum. |
| **7**    | Dynamic Programming (Part II) | - [62. Unique Paths](https://leetcode.cn/problems/unique-paths/) (Medium): Solve a grid-based DP problem.<br> - [63. Unique Paths II](https://leetcode.cn/problems/unique-paths-ii/) (Medium): Extend DP with obstacles.<br> - [45. Jump Game II](https://leetcode.cn/problems/jump-game-ii/) (Medium): Use DP or greedy for minimum jumps. |
| **8**    | Dynamic Programming (Part III); Dynamic Programming (Part IV) | - [5. Longest Palindromic Substring](https://leetcode.cn/problems/longest-palindromic-substring/) (Medium): Apply DP for string problems.<br> - [1143. Longest Common Subsequence](https://leetcode.cn/problems/longest-common-subsequence/) (Medium): Solve a classic DP problem.<br> - [322. Coin Change](https://leetcode.cn/problems/coin-change/) (Medium): Use DP for optimization. |
| **9**    | Linear Programs, Simplex Algorithm; Network Flow, Bipartite Matching | - [785. Is Graph Bipartite?](https://leetcode.cn/problems/is-graph-bipartite/) (Medium): Check if a graph is bipartite using BFS/DFS.<br> - [1584. Min Cost to Connect All Points](https://leetcode.cn/problems/min-cost-to-connect-all-points/) (Medium): Revisit MST for connectivity.<br> - [127. Word Ladder](https://leetcode.cn/problems/word-ladder/) (Medium): Use BFS for shortest transformation sequence. |
| **10**   | Duality, Zero-Sum Games; Review | - [877. Stone Game](https://leetcode.cn/problems/stone-game/) (Easy): Introduce game theory concepts.<br> - [486. Predict the Winner](https://leetcode.cn/problems/predict-the-winner/) (Medium): Apply DP for game theory.<br> - [464. Can I Win](https://leetcode.cn/problems/can-i-win/) (Medium): Solve a minimax game problem. |
| **11**   | Spring Recess | - **No new problems**: Review problems from Weeks 1–10 to prepare for Midterm 2. |
| **12**   | Reductions, NP-Completeness | - [4. Median of Two Sorted Arrays](https://leetcode.cn/problems/median-of-two-sorted-arrays/) (Hard): Revisit a complex problem requiring optimization.<br> - [23. Merge k Sorted Lists](https://leetcode.cn/problems/merge-k-sorted-lists/) (Hard): Combine multiple concepts.<br> - [42. Trapping Rain Water](https://leetcode.cn/problems/trapping-rain-water/) (Hard): Solve a challenging problem with multiple approaches. |
| **13**   | Reductions; Coping with NP-Completeness | - [300. Longest Increasing Subsequence](https://leetcode.cn/problems/longest-increasing-subsequence/) (Medium): Solve a classic DP problem.<br> - [329. Longest Increasing Path in a Matrix](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/) (Hard): Extend DP to graphs.<br> - [72. Edit Distance](https://leetcode.cn/problems/edit-distance/) (Hard): Apply DP for string transformations. |
| **14**   | Coping with NP-Completeness; Gradient Descent (Part I) | - [378. Kth Smallest Element in a Sorted Matrix](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/) (Medium): Use binary search for optimization.<br> - [692. Top K Frequent Words](https://leetcode.cn/problems/top-k-frequent-words/) (Hard): Apply heap-based optimization.<br> - [452. Minimum Number of Arrows to Burst Balloons](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/) (Medium): Use greedy for interval problems. |
| **15**   | Gradient Descent (Part II); Gradient Descent (Part III), Multiplicative Weights | - [410. Split Array Largest Sum](https://leetcode.cn/problems/split-array-largest-sum/) (Hard): Apply binary search for optimization.<br> - [815. Bus Routes](https://leetcode.cn/problems/bus-routes/) (Medium): Use BFS for route optimization.<br> - [1335. Minimum Difficulty of a Job Schedule](https://leetcode.cn/problems/minimum-difficulty-of-a-job-schedule/) (Medium): Solve a DP-based optimization problem. |

## Detailed Analysis

### Course Context
The CS170 Spring 2024 course at UC Berkeley, taught by Prasad Raghavendra and Christian Borgs, covers efficient algorithms and intractable problems. The syllabus includes foundational topics like Big-O notation, divide-and-conquer algorithms, graph algorithms, dynamic programming, and advanced concepts like NP-completeness and gradient descent. The course spans 15 weeks, with Week 11 being a Spring Recess and Weeks 7 and 12 including midterms but still covering lecture material on Thursdays.

### Problem Selection Process
The problems were selected by mapping the course’s weekly topics to LeetCode’s problem categories, such as arrays, binary search, graphs, dynamic programming, and greedy algorithms. The goal was to choose problems that reinforce the theoretical concepts while being practical for coding practice. Here’s how the selection was approached:

- **Relevance**: Each problem aligns with the week’s lecture topics. For example, Week 1’s focus on Big-O and recurrences is matched with binary search problems, which emphasize logarithmic complexity.
- **Difficulty**: Most problems are medium difficulty to balance challenge and solvability within 3 hours. Easy problems are included in early weeks to build confidence, while harder problems appear in later weeks to match the course’s increasing complexity.
- **Time Management**: Each week’s problems are estimated to take 1–1.5 hours each, totaling about 3 hours. Hard problems in later weeks may require more time, so students should prioritize understanding over speed.
- **Advanced Topics**: For topics like FFT, Linear Programming, and Gradient Descent, direct LeetCode problems are scarce. Instead, related problems (e.g., optimization via binary search or DP) were chosen to approximate these concepts.

### Week-by-Week Breakdown
- **Week 1**: Focuses on foundational concepts like Big-O notation and divide-and-conquer. Binary search problems (704, 35, 69) are chosen to practice logarithmic time complexity and basic algorithmic thinking.
- **Week 2**: Covers matrix operations and median-finding. Matrix problems (74, 54) reinforce 2D array manipulation, while 215 approximates median-finding by finding the kth largest element.
- **Week 3**: Introduces graph algorithms with DFS and topological sort. Problems 207 and 133 directly address these, while 46 uses DFS for backtracking.
- **Week 4**: Continues with graph algorithms, focusing on connectivity and paths. Problems 743, 994, and 200 cover shortest paths and connected components.
- **Week 5**: Explores greedy algorithms and MST. Problem 55 is a classic greedy problem, 973 uses heaps (related to Huffman encoding), and 1584 applies Kruskal’s algorithm.
- **Week 6**: Introduces Union Find and DP. Problem 547 uses Union Find, while 70 and 53 are simple DP problems to build intuition.
- **Week 7**: Continues DP with grid-based problems (62, 63) and a jump problem (45) that can be solved with DP or greedy methods.
- **Week 8**: Deepens DP with string (5, 1143) and optimization (322) problems, reflecting the course’s focus on advanced DP techniques.
- **Week 9**: Addresses network flow and bipartite matching. Problem 785 directly tests bipartite graphs, while 1584 and 127 involve connectivity and shortest paths.
- **Week 10**: Covers game theory with problems 877, 486, and 464, which use DP and minimax strategies, aligning with duality and zero-sum games.
- **Week 11**: No new topics due to Spring Recess. Students should review problems from Weeks 1–10 to prepare for Midterm 2.
- **Week 12**: Introduces NP-completeness with hard problems (4, 23, 42) that require combining multiple algorithmic techniques, reflecting the complexity of reductions.
- **Week 13**: Continues NP-completeness with problems (300, 329, 72) that involve DP and graph traversal, simulating complex problem-solving.
- **Week 14**: Focuses on optimization with problems (378, 692, 452) that use binary search, heaps, and greedy approaches, approximating gradient descent.
- **Week 15**: Concludes with optimization problems (410, 815, 1335) that involve binary search, BFS, and DP, aligning with gradient descent and multiplicative weights.

### Notes for Students
- **Time Allocation**: Allocate about 1–1.5 hours per problem. For harder problems (e.g., Week 12’s 4 or 23), you may need additional time to understand the solution.
- **Review Strategy**: Use Week 11 to revisit problems you found challenging or to practice mock interviews with peers.
- **Advanced Topics**: For topics like FFT or Linear Programming, focus on understanding the related LeetCode problems’ algorithmic principles, as they approximate the theoretical concepts.
- **Resources**: All problems are accessible on [LeetCode](https://leetcode.cn/). Review the course’s lecture slides and DPV textbook sections for deeper theoretical understanding.

### Conclusion
This plan provides a structured approach to practicing coding problems that complement the CS170 curriculum. By solving these problems weekly, you’ll reinforce your understanding of algorithms and data structures while preparing for coding interviews. Adjust your pace as needed, and use the Spring Recess to solidify your knowledge.
